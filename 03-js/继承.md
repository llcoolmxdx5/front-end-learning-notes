# 继承

## 原型链

ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系:每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。

原型链继承方式的优点在于简单，而缺点也十分致命：

1. 子类之间会共享引用类型属性
2. 创建子类时，无法向父类构造函数传参

```js
function SuperType() {
  this.property = true;
}
SuperType.prototype.getSuperValue = function () {
  return this.property;
};
function SubType() {
  this.subProperty = false;
}
//继承了 SuperType
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function () {
  return this.subProperty;
};
var instance = new SubType();
alert(instance.getSuperValue()); //true
```

问题：

1. 在通过原型来实现继承时，原型实际上会变成另一个类型的实例。
2. 在创建子类型的实例时，不能向超类型的构造函数中传递参数。

## 借用构造函数

在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做借用构造函数 (constructor stealing)的技术(有时候也叫做伪造对象或经典继承)。即在子类型构造函数的内部调用超类型构造函数。

缺点: 父类的方法没有被共享，造成内存浪费

借用构造函数模式，不同于原型式继承和原型模式，它不会共享引用类型属性，而且也可以向超类型构造函数传递参数。但是相对的，由于不会共享属性，也无法实现代码复用，相同的函数在每个实例中都有一份。

```js
function Person(name, age) {
  this.type = "human";
  this.name = name;
  this.age = age;
}
function Student(name, age) {
  // 借用构造函数继承属性成员
  Person.call(this, name, age);
}
var s1 = Student("张三", 18);
console.log(s1.type, s1.name, s1.age); // => human 张三 18
```

## 组合继承

用原型链实现对原型属性和方法的继承(需要共享的)，通过借用构造函数实现对实例属性的继承(不共享的)。这样的方法实现了函数复用，而且每个实例拥有自己的属性。

这是所有继承方式中最常用的，它的优点也十分明显：

1. 可以在创建子类实例时向父类构造函数传参。
2. 引用类型属性的值可以不共享。
3. 可以实现代码复用，即可以共享相同的方法。

但是这种方法依然有一点不足，调用了两次父类的构造函数

```js
function Parent3() {
  this.name = ["super3"];
}
Parent3.prototype.reName = function () {
  this.name.push("super31");
};
function Child3() {
  Parent3.call(this); // 生成子类的实例属性(但是不包括父对象的方法)
}
Child3.prototype = new Parent3(); // 继承父类的属性和方法(副作用: 父类的构造函数被调用的多次，且属性也存在两份造成了内存浪费)
var child31 = new Child3();
var child32 = new Child3();
child31.reName();
console.log(child31.name, child32.name); // [ 'super3', 'super31' ] [ 'super3' ], 子类实例不会相互影响
console.log(child31.reName === child32.reName); //true, 共享了父类的方法
```

## 原型式继承

这种继承借助原型并基于已有的对象创建新对象，同时还不必因此创建自定义类型。

缺点: 子类实例共享属性，造成实例间的属性会相互影响

```js
function Person(name, age) {
  this.type = "human";
  this.name = name;
  this.age = age;
}
Person.prototype.sayName = function () {
  console.log("hello " + this.name);
};
function Student(name, age) {
  Person.call(this, name, age);
}
// 利用原型的特性实现继承
Student.prototype = new Person();
var s1 = Student("张三", 18);
console.log(s1.type); // => human
s1.sayName(); // => hello 张三
```

## 寄生式继承

与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。

寄生式继承把原型式+工厂模式结合而来，目的是为了封装创建对象的过程。

子类都有各自的实例不会相互影响，且共享了父类的方法

寄生式继承在主要考虑对象而不是创建自定义类型和构造函数时，是十分有用的。但是如果考虑到用寄生式继承为对象添加函数等，由于没有用到原型，做不到函数复用，会导致效率降低。

ES6 class 的实现方法

```js
function Parent4() {
  this.name = ["super4"];
}
Parent4.prototype.reName = function () {
  this.name.push("super41");
};
function Child4() {
  Parent4.call(this); // 生成子类的实例属性(但是不包括父对象的方法)
}
Child4.prototype = Object.create(Parent4.prototype); // 该方法会使用指定的原型对象及其属性去创建一个新的对象
var child41 = new Child4();
var child42 = new Child4();
child41.reName();
console.log(child41.name, child42.name); //[ 'super4','super41' ] [ 'super4' ], 子类实例不会相互影响
console.log(child41.reName === child42.reName); //true, 共享了父类的方法
```

## 寄生组合式继承

所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。

集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式

```js
function Parent(value) {
  this.val = value;
}
Parent.prototype.getValue = function () {
  console.log(this.val);
};
function Child(value) {
  Parent.call(this, value);
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true,
  },
});
const child = new Child(1);
child.getValue(); // 1
child instanceof Parent; // true
```
