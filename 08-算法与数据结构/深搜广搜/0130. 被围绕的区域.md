# [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

## 题目

给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。

示例 1：

```txt
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
```

示例 2：

```txt
输入：board = [["X"]]
输出：[["X"]]
```

提示：

- `m == board.length`
- `n == board[i].length`
- `1 <= m`, `n <= 200``
- `board[i][j]` 为 `'X'` 或 `'O'`

## 难度

中等

## 标签

深度优先搜索 广度优先搜索 并查集 数组 矩阵

## 解题思路

### 深度优先搜索

根据题目描述，边界上的 `O` 与与边界上相连的 `O` 都不会被填充。所以按以下步骤来做：

- 从四条边深度优先搜索，将关联到的 `O` 用任意字符(这里用 `#`)标记;
- 遍历矩阵(四条边不用遍历)，将所有的 `O` 换为 `X`
- 遍历整个矩阵，将之前的 `#` 换为 `O`

复杂度分析

- 时间复杂度：`O(n×m)`，深度优先搜索，每个点至多只会被标记一次。
- 空间复杂度：`O(n×m)`，深度优先搜索的栈的开销。

### 广度优先

- `visited` 记录所有和四边相邻的 `O` 坐标
- `v2` 记录所有出现过的的 `O` 坐标
- 将 `v2` 中 `visited` 没有的坐标值置为 `X`

复杂度分析

- 时间复杂度：`O(n×m)`，广度优先搜索过程中，每个点至多只会被标记一次。
- 空间复杂度：`O(n×m)`，广度优先搜索的队列的开销。

## 提交速度

- 执行用时：`100 ms`, 在所有 JavaScript 提交中击败了`44.66%`的用户
- 内存消耗：`42.1 MB`, 在所有 JavaScript 提交中击败了`48.04%`的用户
