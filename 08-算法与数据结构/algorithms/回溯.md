# 回溯

## 模板

```js
result = [];
function backtrack(路径, 选择列表) {
  if (满足结束条件) {
    result.push(路径);
    return;
  }
  for (选择 in 选择列表) {
    // 做选择(前序遍历)
    backtrack(路径, 选择列表);
    // 撤销选择(后续遍历)
  }
}
```

## 总结

回溯算法就是一个多叉树的遍历问题, 关键就是在前序遍历和后序遍历的位置做一些操作

写 `backtrack` 函数时, 需要维护走过的**路径**和当前可以做的**选择列表**, 当触发**结束条件**时, 将**路径**记入结果集

动态规划的暴力求解阶段就是回溯算法, 没有重复子问题就是回溯算法了, 想不出状态转移方程时可以采用回溯算法, 复杂度较高, 但也不失为一种方法

## 题目

- [x] 0017 电话号码的字母组合 中等
- [x] 0022 括号生成 中等
- [ ] 0037 解数独 中等
- [x] 0039 组合总和 中等
- [x] 0040 组合总和 II 中等
- [x] 0046 全排列 中等
- [x] 0046 全排列 II 中等
- [ ] 0051 N 皇后 中等
- [x] 0077 组合 中等
- [x] 0078 子集 中等
- [x] 0079 单词搜索 中等
- [x] 0090 子集 II 中等
- [ ] 0419 格雷编码 中等
- [x] 0488 祖玛游戏 困难
- [x] 0797 所有可能的路径 中等
- [x] 0869 重新排序得到 2 的幂 中等
