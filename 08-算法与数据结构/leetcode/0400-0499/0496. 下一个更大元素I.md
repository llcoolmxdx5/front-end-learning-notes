# [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

## 题目

给你两个**没有重复元素**的数组 `nums1` 和 `nums2` ，其中 `nums1` 是 `nums2` 的子集。

请你找出 `nums1` 中每个元素在 `nums2` 中的下一个比其大的值。

`nums1` 中数字  `x`  的下一个更大元素是指  `x`  在  `nums2`  中对应位置的右边的第一个比  `x`  大的元素。如果不存在，对应位置输出 -1 。

示例 1:

```txt
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。
    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。
    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```

示例 2:

```txt
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```

提示：

- `1 <= nums1.length <= nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 10^4`
- `nums1`和`nums2`中所有整数**互不相同**
- `nums1` 中的所有整数同样出现在 `nums2` 中

进阶：你可以设计一个时间复杂度为 `O(nums1.length + nums2.length)` 的解决方案吗？

## 难度

简单

## 标签

栈 数组 哈希表 单调栈

## 解题思路

### 方法一：暴力

复杂度分析

- 时间复杂度：`O(mn)`，其中 `m` 是 `nums1` 的长度，`n` 是 `nums2` 的长度。
- 空间复杂度：`O(1)`。

### 方法二：单调栈 + 哈希表

我们可以先预处理 `nums2` ，使查询 `nums1` 中的每个元素在 `nums2` 中对应位置的右边的第一个更大的元素值时不需要再遍历 `nums2` 。于是，我们将题目分解为两个子问题：

- 第 1 个子问题：如何更高效地计算 `nums2` 中每个元素右边的第一个更大的值；
- 第 2 个子问题：如何存储第 1 个子问题的结果。

我们可以使用单调栈来解决第 1 个子问题。倒序遍历 `nums2` ，并用单调栈中维护当前位置右边的更大的元素列表，从栈底到栈顶的元素是单调递减的。

具体地，每次我们移动到数组中一个新的位置 `i`，就将当前单调栈中所有小于 `nums2[i]` 的元素弹出单调栈，当前位置右边的第一个更大的元素即为栈顶元素，如果栈为空则说明当前位置右边没有更大的元素。随后我们将位置 `i` 的元素入栈。

因为在这道题中我们只需要用到 `nums2` 中元素的顺序而不需要用到下标，所以栈中直接存储 `nums2` 中元素的值即可。

复杂度分析

- 时间复杂度：`O(m+n)`，其中 `m` 是 `nums1` 的长度，`n` 是 `nums2` 的长度。我们需要遍历 `nums2` 以计算 `nums2` 中每个元素右边的第一个更大的值；需要遍历 `nums1` 以生成查询结果。
- 空间复杂度：`O(n)`，用于存储哈希表。

## 提交速度

- 执行用时：`80 ms`, 在所有 JavaScript 提交中击败了 `50.42%` 的用户
- 内存消耗：`39.3 MB`, 在所有 JavaScript 提交中击败了 `71.79%` 的用户
