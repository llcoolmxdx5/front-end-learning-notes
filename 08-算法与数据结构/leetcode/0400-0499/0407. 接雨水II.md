# [407. 接雨水II](https://leetcode-cn.com/problems/trapping-rain-water-ii/)

## 题目

给你一个 `m x n` 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。

示例 1:

![alt](./imgs/407-eg1.jpeg)

```txt
输入: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
输出: 4
解释: 下雨后，雨水将会被上图蓝色的方块中。总的接雨水量为1+2+1=4。
```

示例  2:

```txt
输入: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
输出: 10
```

提示:

- `m == heightMap.length`
- `n == heightMap[i].length`
- `1 <= m, n <= 200`
- `0 <= heightMap[i][j] <= 2 * 10^4`

## 难度

困难

## 标签

广度优先搜索 数组 矩阵 堆(优先队列)

## 解题思路

### 最短路算法

首先，最外面一层，外面是没有方块的，是无法接水的，与最外一层相邻方块，也被最外一层的“影响”，和“短板效应”的思想有点相似，因此我们可以利用最外一层作为突破口，然后往里面找。

我们可以用最短路算法 Dijkstra 算法解决该问题，Dijkstra 利用堆(优先队列)维护了一个有序结构，每次拿出最短的边，我们可以利用最短路思想，把边迁移为“方块的高度”，进而解决我们这个问题。

设方块 `(i,j)` 的最终的高度为 `h[i][j]`，那么 `h[i][j] = max(heightMap[i][j], min(h[i-1][j], h[i+1][j], h[i][j-1], h[i][j +1]))`。

最短路找的过程有几个注意点：

- 优先从矮的的方块开始找，一个格子周围有四个方块，但最终的盛水量，取决于最矮一个。
- 计算完当前方块盛水量，要更新当前点的高度，`h[i][j] = max(heightMap[i][j], min(h[i-1][j], h[i+1][j], h[i][j-1], h[i][j +1]))`。

复杂度分析

- 时间复杂度：`O(MN(M+N))`，其中 `M` 是矩阵的行数，`N` 是矩阵的列数。我们需要将矩阵中的每个元素都进行遍历，同时将每个元素都需要插入到优先队列中，总共需要向队列中插入 `MN` 个元素，每次优先队列进行调整的时间复杂度为 `O(M+N)`，因此总的时间复杂度为 `O(MN(M+N))` 如果是堆实现的优先队列 则是 `O(MNlog(M+N))`。
- 空间复杂度：`O(MN)`，其中 `M` 是矩阵的行数，`N` 是矩阵的列数。我们需要创建额外的空间对元素进行标记，优先队列中最多存储 `O(MN)` 个元素，因此空间复杂度度为 `O(MN)`。

## 提交速度

- 执行用时：`516 ms`, 在所有 JavaScript 提交中击败了 `5.88%` 的用户
- 内存消耗：`45.7 MB`, 在所有 JavaScript 提交中击败了 `100.00%` 的用户
