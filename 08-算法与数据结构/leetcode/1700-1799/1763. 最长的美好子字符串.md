# [1763. 最长的美好子字符串](https://leetcode-cn.com/problems/longest-nice-substring/)

## 题目

当一个字符串 `s` 包含的每一种字母的大写和小写形式**同时**出现在 `s` 中，就称这个字符串 `s` 是**美好**字符串。比方说，`"abABB"` 是美好字符串，因为 `'A'` 和 `'a'` 同时出现了，且 `'B'` 和 `'b'` 也同时出现了。然而，`"abA"` 不是美好字符串因为 `'b'` 出现了，而 `'B'` 没有出现。

给你一个字符串 `s` ，请你返回 `s` 最长的**美好子字符串**。如果有多个答案，请你返回**最早**出现的一个。如果不存在美好子字符串，请你返回一个空字符串。

示例 1：

```txt
输入：s = "YazaAay"
输出："aAa"
解释："aAa" 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 'a' 和大写形式 'A' 也同时出现了。
"aAa" 是最长的美好子字符串。
```

示例 2：

```txt
输入：s = "Bb"
输出："Bb"
解释："Bb" 是美好字符串，因为 'B' 和 'b' 都出现了。整个字符串也是原字符串的子字符串。
```

示例 3：

```txt
输入：s = "c"
输出：""
解释：没有美好子字符串。
```

示例 4：

```txt
输入：s = "dDzeE"
输出："dD"
解释："dD" 和 "eE" 都是最长美好子字符串。
由于有多个美好子字符串，返回 "dD" ，因为它出现得最早。
```

提示：

- `1 <= s.length <= 100`
- `s` 只包含大写和小写英文字母。

## 难度

简单

## 标签

位运算 哈希表 字符串 滑动窗口

## 解题思路

### 方法一: 暴力法

### 方法二: 枚举

题目要求找到最长的美好子字符串，题目中给定的字符串 `s` 的长度 `length` 范围为 `1≤length≤100`。由于字符串的长度比较小，因此可以枚举所有可能的子字符串，然后检测该字符串是否为美好的字符串，并得到长度最长的美好字符串。

题目关于美好字符串的定义为: 字符串中的每个字母的大写和小写形式同时出现在该字符串中。检测时，由于英文字母 `‘a’−‘z’` 最多只有 `26` 个, 因此可以利用二进制位来进行标记，`lower` 标记字符中出现过小写英文字母，`upper` 标记字符中出现过大写英文字母。如果满足 `lower==upper` ，我们则认为字符串中所有的字符都满足大小写形式同时出现，则认定该字符串为美好字符串。

题目要求如果有多个答案，返回在字符串中最早出现的那个。此时，只需要首先检测从以字符串索引 0 为起始的子字符串。

复杂度分析

- 时间复杂度：`O(n^2)`，其中 `n` 为字符串的长度。需要枚举所有可能的子字符串，因此需要双重循环遍历字符串，总共可能有 `n^2` 个连续的子字符串。
- 空间复杂度：`O(1)`。由于返回值不需要计算空间复杂度，除了需要两个整数变量用来标记以外不需要额外的空间。

### 方法三: 分治

将原问题拆解成子问题，如果某个字符在当前字符串中没有它对应的大写或小写字符，它必不能构成答案中的一部分，答案只能在它左边或在它右边。

我们返回该点左边或右边更长的答案即为答案。

如果不存在这样的字符，说明原字符串本身就是美好字符串。

## 提交速度

- 执行用时：`68 ms`, 在所有 JavaScript 提交中击败了`98.81%`的用户
- 内存消耗：`41.6 MB`, 在所有 JavaScript 提交中击败了`72.62%`的用户
