# [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

## 题目

给定一个正整数 `n`，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

```txt
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

示例 2:

```txt
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

说明: 你可以假设 `n` 不小于 2 且不大于 58。

## 难度

中等

## 标签

数学 动态规划

## 解题思路

### 动态规划

1. 确定 dp 数组（dp table）以及下标的含义
   `dp[i]`：分拆数字 `i`，可以得到的最大乘积为 `dp[i]`。

2. 确定递推公式
   可以想 `dp[i]`最大乘积是怎么得到的呢？其实可以从 1 遍历 `j`，然后有两种渠道得到 `dp[i]`.

   - 一个是 `j * (i - j)` 直接相乘。
   - 一个是 `j * dp[i - j]`，相当于是拆分`(i - j)`，对这个拆分不理解的话，可以回想 `dp` 数组的定义。

   `j` 怎么就不拆分呢？`j` 是从 1 开始遍历，拆分 `j` 的情况，在遍历 `j` 的过程中其实都计算过了。那么从 1 遍历 `j`，比较`(i - j) * j` 和 `dp[i - j] * j` 取最大的。递推公式：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))`;

   也可以这么理解，`j * (i - j)` 是单纯的把整数拆分为两个数相乘，而 `j * dp[i - j]`是拆分成两个以及两个以上的个数相乘。如果定义 `dp[i - j] * dp[j]` 也是默认将一个数强制拆成 4 份以及 4 份以上了。所以递推公式：`dp[i] = max(dp[i], (i - j) * j, dp[i - j] * j)`;

   那么在取最大值的时候，为什么还要比较 `dp[i]`呢？因为在递推公式推导的过程中，每次计算 `dp[i]`，取最大的而已。

3. dp 的初始化
   初始化为 0, 虽然`dp[0]` 和 `dp[1]` 无意义

4. 确定遍历顺序
   确定遍历顺序，先来看看递归公式：`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))`;

   `dp[i]` 是依靠 `dp[i - j]` 的状态，所以遍历 `i` 一定是从前向后遍历，先有 `dp[i - j]` 再有 `dp[i]`。

   枚举 `j` 的时候，是从 0 开始的。`i` 是从 2 开始，这样 `dp[i - j]` 就是 `dp[2]` 正好可以通过我们初始化的数值求出来。

## 提交速度

- 执行用时：`72 ms`, 在所有 JavaScript 提交中击败了 `56.25%` 的用户
- 内存消耗：`37.9 MB`, 在所有 JavaScript 提交中击败了 `32.76%` 的用户
