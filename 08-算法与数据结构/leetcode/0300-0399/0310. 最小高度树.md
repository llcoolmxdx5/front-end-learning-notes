# [310. 最小高度树](https://leetcode-cn.com/problems/minimum-height-trees/)

## 题目

树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。

给你一棵包含 `n` 个节点的树，标记为 0 到 `n - 1` 。给定数字 `n` 和一个有 `n - 1` 条无向边的 `edges` 列表（每一个边都是一对标签），其中 `edges[i] = [ai, bi]` 表示树中节点 `ai` 和 `bi` 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 `x` 作为根节点时，设结果树的高度为 `h` 。在所有可能的树中，具有最小高度的树（即，`min(h)`）被称为**最小高度树**。

请你找到所有的**最小高度树**并按**任意顺序**返回它们的根节点标签列表。

树的**高度**是指根节点和叶子节点之间最长向下路径上边的数量。

示例 1：

```txt
输入：n = 4, edges = [[1,0],[1,2],[1,3]]
输出：[1]
解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。
```

示例 2：

```txt
输入：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
输出：[3,4]
```

提示：

- `1 <= n <= 2 * 10^4`
- `edges.length == n - 1`
- `0 <= ai, bi < n`
- `ai != bi`
- 所有 `(ai, bi)` 互不相同
- 给定的输入**保证**是一棵树，并且**不会有重复的边**

## 难度

中等

## 标签

广度优先搜索 深度优先搜索 图 拓扑排序

## 解题思路

### 解法 1：DFS

DFS 解法简单粗暴：

1. 建图
2. 遍历图的各个顶点，找出以该顶点为根的树的深度
3. 返回最小深度的结果（细想可知：结果数组只能含 1 或 2 个元素）

超时

### 解法 2：拓扑排序思想

1. 我们知道，结果返回一个数组，而该数组的元素个数只能为 1 或 2，因为它是图的深度优先搜索的最长路径中点，而中点可能为 1 或 2 个元素。
2. 因为是中点，所以树的叶节点断然不可能是结果，因此可以通过以下步骤求解：
   1. 建图，同时维护无向图的个顶点的度
   2. 初始化队列，将度为 1 的顶点入队
   3. 使用循环剪掉所有叶节点（度为 1 的节点），剪掉叶节点的同时必然会生成新的叶节点，再将新的叶节点入队
   4. 当队列为空时，到达最长路径的中心
3. 过程和返回值：将过程类比为 “剥洋葱”，每一次 “剪叶” 相当于剥掉洋葱的一层，而这一层数据保存在队列中；也就是说，队列的每一 “帧” 保存的是下一次要剪掉的叶节点，所以队列的最后一 “帧” 就是返回值

## 提交速度

- 执行用时：`672 ms`, 在所有 JavaScript 提交中击败了`33.33%`的用户
- 内存消耗：`62.7 MB`, 在所有 JavaScript 提交中击败了`56.57%`的用户
