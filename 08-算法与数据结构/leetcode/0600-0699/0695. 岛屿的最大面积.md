# [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

## 题目

给你一个大小为 `m x n` 的二进制矩阵 `grid` 。

岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 `grid` 的四个边缘都被 0（代表水）包围着。

岛屿的面积是岛上值为 1 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。

示例 1：

![695-eg1](./imgs/695-eg1.jpeg)

```txt
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

示例 2：

```txt
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

提示：

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m`, `n <= 50`
- `grid[i][j]` 为 0 或 1

## 难度

简单

## 标签

深度优先搜索 广度优先搜索 并查集 矩阵

## 解题思路

- 我们想知道网格中每个连通形状的面积，然后取最大值。
- 如果我们在一个土地上，以 4 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。
- 为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 0。这样我们就不会多次访问同一土地。

复杂度分析

- 时间复杂度：`O(R×C)`。其中 `R` 是给定网格中的行数，`C` 是列数。我们访问每个网格最多一次。
- 空间复杂度：`O(R×C)`，队列中最多会存放所有的土地，土地的数量最多为 `R×C` 块，因此使用的空间为 `O(R×C)`。

## 提交速度

- 执行用时：`100 ms`, 在所有 JavaScript 提交中击败了 `25.98%` 的用户
- 内存消耗：`44.1 MB`, 在所有 JavaScript 提交中击败了 `13.52%` 的用户
