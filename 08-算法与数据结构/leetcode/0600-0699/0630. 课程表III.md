# [0630. 课程表 III](https://leetcode-cn.com/problems/course-schedule-iii/)

## 题目

这里有 `n` 门不同的在线课程，按从 1 到 `n`  编号。给你一个数组 `courses` ，其中 `courses[i] = [duration_i, lastDay_i]` 表示第 `i` 门课将会**持续**上 `duration_i` 天课，并且必须在不晚于 `lastDay_i` 的时候完成。

你的学期从第 1 天开始。且不能同时修读两门及两门以上的课程。

返回你最多可以修读的课程数目。

示例 1：

```txt
输入：courses = [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出：3
解释：
这里一共有 4 门课程，但是你最多可以修 3 门：
首先，修第 1 门课，耗费 100 天，在第 100 天完成，在第 101 天开始下门课。
第二，修第 3 门课，耗费 1000 天，在第 1100 天完成，在第 1101 天开始下门课程。
第三，修第 2 门课，耗时 200 天，在第 1300 天完成。
第 4 门课现在不能修，因为将会在第 3300 天完成它，这已经超出了关闭日期。
```

示例 2：

```txt
输入：courses = [[1,2]]
输出：1
```

示例 3：

```txt
输入：courses = [[3,2],[4,3]]
输出：0
```

提示:

- `1 <= courses.length <= 10^4`
- `1 <= duration_i`, `lastDay_i <= 10^4`

## 难度

困难

## 标签

贪心 数组 堆(优先队列)

## 解题思路

我们需要一个数据结构支持「取出 `t` 值最大的那门课程」，因此我们可以使用优先队列（大顶堆）。

我们依次遍历每一门课程，当遍历到 `(t_i, d_i)`时：

- 如果当前优先队列中所有课程的总时间与 `t_i` 之和小于等于 `d_i`，那么我们就把 `t_i` 加入优先队列中；
- 如果当前优先队列中所有课程的总时间与 `t_i` 之和大于 `d_i` ，那么我们找到优先队列中的最大元素 `t_j`。如果 `t_j > t_i` ，则将它移出优先队列，并把 `t_i` 加入优先队列中。

在遍历完成后，优先队列中包含的元素个数即为答案。

## 提交速度

- 执行用时：`168 ms`, 在所有 TypeScript 提交中击败了 `100.00%` 的用户
- 内存消耗：`46.8 MB`, 在所有 TypeScript 提交中击败了 `100.00%` 的用户
