# [629. K 个逆序对数组](https://leetcode-cn.com/problems/k-inverse-pairs-array/)

## 题目

给出两个整数 `n` 和 `k`，找出所有包含从 1 到 `n` 的数字，且恰好拥有 `k` 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第 `i` 个和第 `j` 个元素，如果满足 `i < j` 且 `a[i] > a[j]`，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 `mod 10^9 + 7` 的值。

示例 1:

```txt
输入: n = 3, k = 0
输出: 1
解释:
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
```

示例 2:

```txt
输入: n = 3, k = 1
输出: 2
解释:
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
```

说明:

1. `n` 的范围是 `[1, 1000]` 并且 `k` 的范围是 `[0, 1000]`。

## 难度

困难

## 标签

动态规划

## 解题思路

我们的目标是要求得前 `n` 个数的数组中正好有 `k` 个逆序对的数量，那么，我们可以思考一下，这个结果能否从前 `n-1` 个数的数组中转移过来？

因为第 `n` 个数（即 `n`）肯定比前 `n-1` 个数大，所以，我们可以把数字 `n` 插入到 `0~n-1` 的不同位置：

- 假如前 `n-1` 个数的数组中正好有 `k` 个逆序对，那么，我们可以把 `n` 插入到这个数组的最后一位，得到的新数组正好也是 `k` 个逆序对，因为，新插入的 `n` 不会与任何数字组成逆序对，而原来数组中的逆序对保持不变；
- 假如前 `n-1` 个数的数组中正好有 `k-1` 个逆序对，那么，我们可以把 `n` 插入到这个数组的倒数第二位，这样，我们会得到 1 个新的逆序对，即原数组的最后一位与 `n` 组成的逆序对，而原来数组中的 `k-1` 个逆序对保持不变，总共会有 `k` 个逆序对；
- 假如前 `n-1` 个数的数组中正好有 `k-2` 个逆序对，那么，我们可以把 `n` 插入到这个数组的倒数第三位，这样，我们会得到 2 个新的逆序对，即原数组的最后两位与 `n` 组成的逆序对，而原来数组中的 `k-2` 个逆序对保持不变，总共会有 `k` 个逆序对；
- ...
- 假如前 `n-1` 个数的数组中正好有 `0(k-k)` 个逆序对，那么，我们可以把 `n` 插入到这个数组的倒数第 `k+1` 位，这样，我们会得到 `k` 个新的逆序对，即原数组的最后 `k` 位与 `n` 组成的逆序对，而原来数组中的 0 个逆序对保持不变，总共会有 `k` 个逆序对；

所以，我们可以得出递推公式为：`f(n)(k)=f(n−1)(k)+f(n−1)(k−1)+...+f(n−1)(0)`。

我们再来看看边界的问题。

- 第一个边界，上面描述中的倒数第 `x` 位，不能超过原数组的下标 0，所以，假设前 `n-1` 个数中正好有 `k-i` 个逆序对，这个 `k-i` 必须小于等于 `n-1`，即 `i >= k-n+1`，这个等会看代码中有用到。
- 第二个边界，对于 `n` 个数组成的数组最多有多少个逆序对？这种情况对应到所有数倒序排列，那么，对于 `n` 来说有 `n-1` 个逆序对，对于 `n-1` 来说有 `n-2` 个逆序对，...，对于 1 来说没有逆序对，所以，最多有 `(n-1) + (n-2) + ... + 0 = n(n-1)/2`。所以，对于 `k` 大于 `n(n-1)/2` 的输入直接返回 0。

### 动态规划

- 状态定义：`dp[i][j]` 表示前 `i` 个数的数组中正好有 `j` 个逆序对的个数；
- 状态转移：`dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-i-1]`；
- 初始值：`dp[1][0]=1`；
- 返回值：`dp[n][k]`；

时间复杂度：`O(nk^2)`。
空间复杂度：`O(nk)`。

### 优化时间

`dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-(i-1)]`

同样地，`dp[i][j-1] = dp[i-1][j-1] + ... + dp[i-1][j-1-(i-1-1)] + dp[i-1][j-1-(i-1)]`

上面的公式减下面的公式可得：`dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i]`

时间复杂度：`O(nk)`​。
空间复杂度：`O(nk)`

### 压缩空间

可以看到公式 `dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i]` 只与 `i-1` 项有关，所以，我们可以使用一个二维数组来交替使用降低空间复杂度。

时间复杂度：`O(nk)`​。
空间复杂度：`O(k)`​。

## 提交速度

- 执行用时：`108 ms`, 在所有 JavaScript 提交中击败了 `64%` 的用户
- 内存消耗：`39.7 MB`, 在所有 JavaScript 提交中击败了 `70%` 的用户
