# [673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

## 题目

给定一个未排序的整数数组，找到最长递增子序列的个数。

示例 1:

```txt
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
```

示例 2:

```txt
输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
```

注意: 给定的数组长度不超过 2000 并且结果一定是 32 位有符号整数。

## 难度

中等

## 标签

树状数组 线段树 数组 动态规划

## 解题思路

本题是「300. 最长递增子序列」的进阶版本

### 方法一：动态规划

按照套路，`dp(i)` 就表示以第 `i` 个字符串结尾的最长上升子序列长度，那么重点是，`dp(i)` 怎么通过之前的推导出来呢？

由于是不连续的，因此不能只看 `dp(i-1)` 了，因为 `nums[i]` 项与 `dp(j)`（其中 `0 <= j < i`）组合后都可能达到最大长度，因此需要遍历所有 `j`，尝试其中最大长度的组合。

所以状态转移方程为：`dp[i] = max(dp[j]) + 1`，其中 `0<=j<i` 且 `nums[j]<nums[i]`。

对于 `cnt[i]`，其等于所有满足 `dp[j]+1=dp[i]` 的 `cnt[j]` 之和。在代码实现时，我们可以在计算 `dp[i]` 的同时统计 `cnt[i]` 的值。

复杂度分析

- 时间复杂度：`O(n^2)`，其中 `n` 是数组 `nums` 的长度。
- 空间复杂度：`O(n)`。

### 方法二：贪心 + 前缀和 + 二分查找

「300. 最长递增子序列」的方法二上进行扩展

复杂度分析

- 时间复杂度：`O(nlogn)`，其中 `n` 是数组 `nums` 的长度。对 `nums` 中的每个元素我们需要执行至多两次二分查找，每次耗时 `O(logn)`，因此时间复杂度为 `O(nlogn)`。
- 空间复杂度：`O(n)`。

## 提交速度

- 执行用时：`92 ms`, 在所有 `JavaScript` 提交中击败了 `84.94%` 的用户
- 内存消耗：`39.6 MB`, 在所有 `JavaScript` 提交中击败了 `84.33%` 的用户
