# [1034. 边界着色](https://leetcode-cn.com/problems/coloring-a-border/)

## 题目

给你一个大小为 `m x n` 的整数矩阵 `grid` ，表示一个网格。另给你三个整数 `row`、`col` 和 `color` 。网格中的每个值表示该位置处的网格块的颜色。

当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一**连通分量**。

**连通分量的边界**是指连通分量中的所有与不在分量中的网格块相邻（四个方向上）的所有网格块，或者在网格的边界上（第一行/列或最后一行/列）的所有网格块。

请你使用指定颜色 `color` 为所有包含网格块 `grid[row][col]` 的**连通分量的边界**进行着色，并返回最终的网格 `grid` 。

示例 1：

```txt
输入：grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
输出：[[3,3],[3,2]]
```

示例 2：

```txt
输入：grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
输出：[[1,3,3],[2,3,3]]
```

示例 3：

```txt
输入：grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2
输出：[[2,2,2],[2,1,2],[2,2,2]]
```

提示：

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `1 <= grid[i][j]`, `color <= 1000`
- `0 <= row < m`
- `0 <= col < n`

## 难度

中等

## 标签

广度优先搜索 深度优先搜索 数组 矩阵

## 解题思路

### 广度优先搜索

思路及解法

我们用一个队列来实现广度优先搜索遍历连通分量，并用一个大小和 `grid` 相同的矩阵 `visited` 来记录当前节点是否被访问过，并把边界点存入数组 `borders` 中。

复杂度分析

- 时间复杂度：`O(mn)`，其中 `m` 和 `n` 分别是 `grid` 的行数和列数。在最坏情况下，我们需要访问到 `grid` 中的每个点。
- 空间复杂度：`O(mn)`。我们用一个与 `grid` 相同大小的矩阵来存储每个点是否被遍历过，而其他的空间消耗，比如广度优先搜索用到的队列和用来存储所有边界点的数组，均不超过 `O(mn)`。

## 提交速度

- 执行用时：`96 ms`, 在所有 JavaScript 提交中击败了 `44.44%` 的用户
- 内存消耗：`43.1 MB`, 在所有 JavaScript 提交中击败了 `5.55%` 的用户
