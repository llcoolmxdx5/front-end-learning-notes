# [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

## 题目

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

示例 1：

```txt
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

示例 2：

```txt
输入：head = [1,2]
输出：[2,1]
```

示例 3：

```txt
输入：head = []
输出：[]
```

提示：

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`

进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

## 难度

简单

## 标签

递归 链表

## 解题思路

### 迭代

在遍历链表时，将当前节点的 `next` 指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。

复杂度分析

- 时间复杂度：`O(n)`，其中 `n` 是链表的长度。需要遍历链表一次。
- 空间复杂度：`O(1)`。

### 递归

递归版本稍微复杂一些，其关键在于反向工作。假设链表的其余部分已经被反转，现在应该如何反转它前面的部分？

假设链表为：`n_1 ... n_k ... n_m`

若从节点 `n_k+1`到 `n_m` 已经被反转，而我们正处于 `n_k`

我们希望 `n_k+1`的下一个节点指向 `n_k`所以，`n_k.next.next=n_k`需要注意的是 `n_1`的下一个节点必须指向 `null`。如果忽略了这一点，链表中可能会产生环

复杂度分析

- 时间复杂度：`O(n)`，其中 `n` 是链表的长度。需要对链表的每个节点进行反转操作。
- 空间复杂度：`O(n)`，其中 `n` 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 `n` 层。

## 提交速度

- 执行用时：`76 ms`, 在所有 TypeScript 提交中击败了`85.40%`的用户
- 内存消耗：`39.8 MB`, 在所有 TypeScript 提交中击败了`71.89%`的用户
