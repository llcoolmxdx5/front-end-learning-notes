# [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

## 题目

给定一个包含 `[0, n]`  中  `n`  个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

示例 1：

```txt
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

示例 2：

```txt
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

示例 3：

```txt
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
```

示例 4：

```txt
输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
```

提示：

- `n == nums.length`
- `1 <= n <= 10^4`
- `0 <= nums[i] <= n`
- `nums` 中的所有数字都**独一无二**

进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

## 难度

简单

## 标签

位运算 数组 哈希表 数学 排序

## 解题思路

### 方法一：位运算

数组 `nums` 中有 `n` 个数，在这 `n` 个数的后面添加从 0 到 `n` 的每个整数，则添加了 `n+1` 个整数，共有 `2n+1` 个整数。

在 `2n+1` 个整数中，丢失的数字只在后面 `n+1` 个整数中出现一次，其余的数字在前面 `n` 个整数中（即数组中）和后面 `n+1` 个整数中各出现一次，即其余的数字都出现了两次。

根据出现的次数的奇偶性，可以使用按位异或运算得到丢失的数字。按位异或运算 `⊕` 满足交换律和结合律，且对任意整数 `x` 都满足 `x⊕x=0` 和 `x⊕0=x`。

由于上述 `2n+1` 个整数中，丢失的数字出现了一次，其余的数字都出现了两次，因此对上述 `2n+1` 个整数进行按位异或运算，结果即为丢失的数字

复杂度分析

- 时间复杂度：`O(n)`，其中 `n` 是数组 `nums` 的长度。需要对 `2n+1` 个数字计算按位异或的结果。
- 空间复杂度：`O(1)`。

### 方法二：数学

将从 0 到 `n` 的全部整数之和记为 `total`，根据高斯求和公式，有：`total = n(n + 1) / 2`

将数组 `nums` 的元素之和记为 `arrSum`，则 `arrSum` 比 `total` 少了丢失的一个数字，因此丢失的数字即为 `total` 与 `arrSum` 之差。

复杂度分析

- 时间复杂度：`O(n)`，其中 `n` 是数组 `nums` 的长度。需要 `O(1)` 的时间计算从 0 到 `n` 的全部整数之和以及需要 `O(n)` 的时间计算数组 `nums` 的元素之和。
- 空间复杂度：`O(1)`。

## 提交速度

- 执行用时：`76 ms`, 在所有 `JavaScript` 提交中击败了 `77.57%` 的用户
- 内存消耗：`39.9 MB`, 在所有 `JavaScript` 提交中击败了 `91.91%` 的用户
