# [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

## 题目

给你一个长度为 `n` 的整数数组 `nums`，其中 `n > 1`，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

示例:

```txt
输入: [1,2,3,4]
输出: [24,12,8,6]
```

提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

说明: 请不要使用除法，且在 `O(n)` 时间复杂度内完成此题。

进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）

## 难度

中等

## 标签

数组 前缀和

## 解题思路

### 法一 左右乘积列表

创建两个数组 `L` `R`, 分别保存对应位置的数字左侧的所有积,和右侧所有数字的积, `L` 第一位为 1, `R` 最后一位为 1
当 `R` 和 `L` 数组填充完成，我们只需要在输入数组上迭代，且索引 `i` 处的值为：`L[i] * R[i]`。

时间复杂度：`O(N)`，其中 `N` 指的是数组 `nums` 的大小。预处理 `L` 和 `R` 数组以及最后的遍历计算都是 `O(N)` 的时间复杂度。
空间复杂度：`O(N)`，其中 `N` 指的是数组 `nums` 的大小。使用了 `L` 和 `R` 数组去构造答案，`L` 和 `R` 数组的长度为数组 `nums` 的大小。

### 法二 空间复杂度 `O(1)` 的方法

尽管上面的方法已经能够很好的解决这个问题，但是空间复杂度并不为常数。

由于输出数组不算在空间复杂度内，那么我们可以将 `L` 或 `R` 数组用输出数组来计算。先把输出数组当作 `L` 数组来计算，然后再动态构造 `R` 数组得到结果

1. 初始化 `answer` 数组，对于给定索引 `i`，`answer[i]` 代表的是 `i` 左侧所有数字的乘积。
2. 构造方式与之前相同，只是我们试图节省空间，先把 `answer` 作为方法一的 `L` 数组。
3. 没有构造 `R` 数组。而是用一个变量来跟踪右边元素的乘积。

## 提交速度

执行用时：`120 ms`, 在所有 JavaScript 提交中击败了 `95.93%` 的用户
内存消耗：`46.8 MB`, 在所有 JavaScript 提交中击败了 `98.52%` 的用户
