# [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

## 题目

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：`pos` 不作为参数进行传递  。仅仅是为了标识链表的实际情况。

如果链表中存在环  ，则返回 `true` 。 否则，返回 `false` 。

示例 1：

![img](./img/141-circularlinkedlist.png)

```txt
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

示例  2：

```txt
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

示例 3：

```txt
输入：head = [1], pos = -1
输出：false
```

解释：链表中没有环。

提示：

- 链表中节点的数目范围是 `[0, 104]`
- `-105 <= Node.val <= 105`
- `pos` 为 `-1` 或者链表中的一个**有效索引**。

## 难度

简单

## 标签

## 解题思路

### 方法一：哈希表

最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。

具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。

### 方法二：快慢指针

我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 `head`，而快指针在位置 `head.next`。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。

## 提交速度

- 执行用时：`76 ms`, 在所有 JavaScript 提交中击败了`49.66%`的用户
- 内存消耗：`43.5 MB`, 在所有 JavaScript 提交中击败了`85.07%`的用户
