# [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

## 题目

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

示例 1:

```txt
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

示例 2:

```txt
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```

提示:

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均**无重复**元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证**为二叉树的前序遍历序列
- `inorder` **保证**为二叉树的中序遍历序列

## 难度

中等

## 标签

树 数组 分治 哈希表 二叉树

## 解题思路

二叉树前序遍历的顺序为：

- 先遍历根节点；
- 随后递归地遍历左子树；
- 最后递归地遍历右子树。

二叉树中序遍历的顺序为：

- 先递归地遍历左子树；
- 随后遍历根节点；
- 最后递归地遍历右子树。

在「递归」地遍历某个子树的过程中，我们也是将这颗子树看成一颗全新的树，按照上述的顺序进行遍历。挖掘「前序遍历」和「中序遍历」的性质，我们就可以得出本题的做法。

### 方法一：递归

只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。

这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。

### 方法二：迭代

## 提交速度

- 执行用时：`112 ms`, 在所有 JavaScript 提交中击败了`62.93%`的用户
- 内存消耗：`81.7 MB`, 在所有 JavaScript 提交中击败了`62.26%`的用户
