# [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

## 题目

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典，判定 `s` 是否可以由空格拆分为一个或多个在字典中出现的单词。

说明：拆分时可以重复使用字典中的单词。

示例 1：

```txt
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```

示例 2：

```txt
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
```

示例 3：

```txt
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

提示：

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅有小写英文字母组成
- `wordDict` 中的所有字符串**互不相同**

## 难度

中等

## 标签

字典树 记忆化搜索 哈希表 字符串 动态规划

## 解题思路

### 法一 动态规划

定义 `dp[i]` 表示字符串 `s` 前 `i` 个字符组成的字符串 `s.slice(0, i)` 是否能被空格拆分成若干个字典中出现的单词。

转移方程: `dp[i] = dp[j] && check(s.slice(j, i))`

对于检查一个字符串是否出现在给定的字符串列表里一般可以考虑哈希表来快速判断，同时也可以做一些简单的剪枝，枚举分割点的时候倒着枚举，如果分割点 `j` 到 `i` 的长度已经大于字典列表里最长的单词的长度，那么就结束枚举

对于边界条件，我们定义 `dp[0] = true` 表示空串且合法。

复杂度分析

- 时间复杂度：`O(n^2)`，其中 `n` 为字符串 `s` 的长度。我们一共有 `O(n)` 个状态需要计算，每次计算需要枚举 `O(n)` 个分割点，哈希表判断一个字符串是否出现在给定的字符串列表需要 `O(1)` 的时间，因此总时间复杂度为 `O(n^2)`。
- 空间复杂度：`O(n)` ，其中 `n` 为字符串 `s` 的长度。我们需要 `O(n)` 的空间存放 `dp` 值以及哈希表亦需要 `O(n)` 的空间复杂度，因此总空间复杂度为 `O(n)`。

### 法二 完全背包

单词就是物品，字符串 `s` 就是背包，单词能否组成字符串 `s`，就是问物品能不能把背包装满。拆分时可以重复使用字典中的单词，说明就是一个完全背包！

`dp[i]` : 字符串长度为i的话，`dp[i]` 为 `true`，表示可以拆分为一个或多个在字典中出现的单词。

如果确定 `dp[j]` 是 `true`，且 `[j, i]` 这个区间的子串出现在字典里，那么 `dp[i]` 一定是 `true`。（j < i ）。

所以递推公式是 if(`[j, i]` 这个区间的子串出现在字典里 && `dp[j]` 是 `true`) 那么 `dp[i] = true`。

- 如果求组合数就是外层for循环遍历物品，内层for遍历背包。
- 如果求排列数就是外层for遍历背包，内层for循环遍历物品。

复杂度分析

- 时间复杂度：`O(n^2)`
- 空间复杂度：`O(n)`

## 提交速度

- 执行用时：`68 ms`, 在所有 `JavaScript` 提交中击败了 `94.27%` 的用户
- 内存消耗：`38.2 MB`, 在所有 `JavaScript` 提交中击败了 `98.13%` 的用户
