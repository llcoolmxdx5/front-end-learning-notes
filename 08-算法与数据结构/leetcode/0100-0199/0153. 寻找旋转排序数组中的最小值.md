# [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

## 题目

已知一个长度为 `n` 的数组，预先按照升序排列，经由 1 到 `n` 次 旋转 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 4 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 7 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值**互不相同**的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的**最小元素**。

示例 1：

```txt
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

示例 2：

```txt
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

示例 3：

```txt
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

提示：

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 中的所有整数 互不相同
- `nums` 原来是一个升序排序的数组，并进行了 1 至 `n` 次旋转

## 难度

中等

## 标签

数组 二分查找

## 解题思路

左、中、右三个位置的值相比较，有以下几种情况：

1. 左值 < 中值, 中值 < 右值 ：没有旋转，最小值在最左边，可以收缩右边界
2. 左值 > 中值, 中值 < 右值 ：有旋转，最小值在左半边，可以收缩右边界
3. 左值 < 中值, 中值 > 右值 ：有旋转，最小值在右半边，可以收缩左边界
4. 左值 > 中值, 中值 > 右值 ：单调递减，不可能出现

分析前面三种可能的情况，会发现情况 1、2 是一类，情况 3 是另一类。

- 如果中值 < 右值，则最小值在左半边，可以收缩右边界。
- 如果中值 > 右值，则最小值在右半边，可以收缩左边界。

## 复杂度分析

- 时间复杂度：时间复杂度为 `O(logn)`，其中 `n` 是数组 `nums` 的长度。在二分查找的过程中，每一步会忽略一半的区间，因此时间复杂度为 `O(logn)`。
- 空间复杂度：`O(1)`。

## 提交速度

- 执行用时：`56 ms`, 在所有 JavaScript 提交中击败了`99.69%`的用户
- 内存消耗：`37 MB`, 在所有 JavaScript 提交中击败了`100%`的用户
