# [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

## 题目

给你两个字符串  `s1`  和  `s2` ，写一个函数来判断 `s2` 是否包含 `s1`  的排列。

换句话说，`s1` 的排列之一是 `s2` 的 子串 。

示例 1：

```txt
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").
```

示例 2：

```txt
输入：s1= "ab" s2 = "eidboaoo"
输出：false
```

提示：

- `1 <= s1.length`, `s2.length <= 10^4`
- `s1` 和 `s2` 仅包含小写字母

## 难度

中等

## 标签

哈希表 双指针 字符串 滑动窗口

## 解题思路

- `s1` 的任意一种排列，是 `s2` 的一个子串。不需要当成全排列问题去做。
- 等价于，`s1` 的每种字符的出现次数，与 `s2` 某个子串的每种字符的出现次数相同。
- s1 字符的出现次数，生成 `map`，去碰撞 `s2` 的子串所对应的 `map`，如果能“全等”，就找到了满足条件的子串。
- 也可以用长度为 26 的数组来代替 `map`，每个索引对应 26 个字母。

### 方法一

- 创建长度 26 的数组 `count1` 和 `count2`，统计 `s1` 字符的出现次数，到 `count1`
- 指针 `start`，保存所要找的 `s2` 子串的开头。
- 指针 `i` 扫 `s2`，更新当前字符的出现次数到 `count2`，同时判断 `start` 上的 `s2` 字符的出现次数，是否已经大于了它在 `s1` 的出现次数
  - 如果大于，说明这个字符，`s1` 并没有那么多，要窗口左移，剔除 `start` 上的 `s2` 字符
  - 如果不大于，说明 `start` 字符在 `s2` 的出现次数还没达到 `s1` 的标准，窗口要扩张。纳入新字符
- 如果遍历过程中 `count1` 和 `count2` 全等，说明找到了满足条件的子串，返回真
  如果遍历 `s2` 结束，始终没有返回真，说明怎么也找不到，返回假

### 方法二

- 创建长度为 26 的数组 `count` 将 `s1` 中出现过的字符对应的位置都减一
- 建立指针 `left` 和 `right`, `right` 每增大一个 就把 `count` 对应位置的值 `+1` 如果对应位置的值大于 0,就向右移动 `left`将对应位置的值 `-1`, 直到应位置的值等于 0
- 如果此时 `[left, right]` 区间的长度恰好等于 `s1` 的长度就说明找到了对应的子串 返回 `true`
- 能循环完后则说明没有找到 返回 `false`

## 复杂度分析

- 时间复杂度：`O(n+m+∣Σ∣)`
- 空间复杂度：`O(∣Σ∣)`

## 提交速度

- 执行用时：`68 ms`, 在所有 JavaScript 提交中击败了`99.45%`的用户
- 内存消耗：`39 MB`, 在所有 JavaScript 提交中击败了`95.76%`的用户
