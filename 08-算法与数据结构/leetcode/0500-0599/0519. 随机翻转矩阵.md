# [519. 随机翻转矩阵](https://leetcode-cn.com/problems/random-flip-matrix/)

## 题目

给你一个 `m x n` 的二元矩阵 `matrix` ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足  `matrix[i][j] == 0` 的下标  `(i, j)` ，并将它的值变为 1 。所有满足 `matrix[i][j] == 0` 的下标 `(i, j)` 被选取的概率应当均等。

尽量最少调用内置的随机函数，并且优化时间和空间复杂度。

实现 `Solution` 类：

- `Solution(int m, int n)` 使用二元矩阵的大小 `m` 和 `n` 初始化该对象
- `int[] flip()` 返回一个满足  `matrix[i][j] == 0` 的随机下标 `[i, j]` ，并将其对应格子中的值变为 1
- `void reset()` 将矩阵中所有的值重置为 0

示例：

```txt
输入
["Solution", "flip", "flip", "flip", "reset", "flip"]
[[3, 1], [], [], [], [], []]
输出
[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]

解释
Solution solution = new Solution(3, 1);
solution.flip();  // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
solution.flip();  // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同
solution.flip();  // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]
solution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回
solution.flip();  // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同
```

提示：

- `1 <= m`, `n <= 10^4`
- 每次调用 `flip` 时，矩阵中至少存在一个值为 0 的格子。
- 最多调用 1000 次 `flip` 和 `reset` 方法。

## 难度

中等

## 标签

水塘抽样 哈希表 数学 随机化

## 解题思路

先掌握一个知识点：二维数组与一维数组之间如何转换？

- 二维转一维：`row * n + col`，即拿横坐标乘以列数，再加上纵坐标；
- 一维转二维：`row = idx / n`, `col = idx % n`，即一维坐标除以列数等于二维的横坐标，一维坐标除以列数的余数等于二维的纵坐标；

### 哈希表

我们可以在 `0 ~ size` 范围内（`size= m * n`）随机生成一个一维坐标，把这个位置的数改为 1（其实并不需要改为 1），然后，把这个位置移到数组的后面（`size-1`的位置），这样，我们下次就可以直接生成 `0 ~ size-1` 范围内随机数了，因为我们刚才把那个生成 1 的位置移到数组的末尾了，所以，这一段是完整的全部都是 0 的，因此，我们可以直接在 `0 ~ size-1` 的范围内生成随机数，且它们的概率是相等的，满足题意。

然而，我们把生成的随机位置移到数组的后面，如果直接交换，我们并不知道原来生成的索引是哪个了，所以，我们需要一个媒介记录这个对应关系，而这正好是一对一的映射，因此，我们可以用哈希表来记录。

复杂度分析

- 时间复杂度：`flip()` 操作的时间复杂度为 `O(1)`，`reset()` 操作的时间复杂度为 `O(F)`，其中 `F` 是在上一次 `reset()` 之后执行 `flip()` 的次数。
- 空间复杂度：`O(F)`，其中 `F` 代表执行函数 `flip()` 的次数。

## 提交速度

- 执行用时：`84 ms`, 在所有 JavaScript 提交中击败了 `100.00%` 的用户
- 内存消耗：`43 MB`, 在所有 JavaScript 提交中击败了 `50.00%` 的用户
