# [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

## 题目

整数数组的一个**排列**就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]` 。

整数数组的**下一个排列**是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的**下一个排列**就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**原地**修改，只允许使用额外常数空间。

示例 1：

```txt
输入：nums = [1,2,3]
输出：[1,3,2]
```

示例 2：

```txt
输入：nums = [3,2,1]
输出：[1,2,3]
```

示例 3：

```txt
输入：nums = [1,1,5]
输出：[1,5,1]
```

提示：

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

## 难度

中等

## 标签

数组 双指针

## 解题思路

### 方法一：两遍扫描

注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：

- 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。
- 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。

以排列 `[4,5,2,6,3,1]` 为例：

1. 我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。
   - 倒序遍历 `2 < 6` 较小数为 2, 下标记为 `left`
   - 倒序查找大于 2 的数 找到 3, 下标记为 `right`
2. 交换 `left` 和 `right`, 当我们完成交换后排列变为 `[4,5,3,6,2,1]`，注意: 步骤一中的 较小数如果找不到跳过这一步,说明是一个降序的序列. 此时 `[left + 1, length)` 区间必为降序区间
3. 此时我们可以重排「较小数」右边的序列, 双指针反转区间 `[left + 1, length)` 即可，序列变为 `[4,5,3,1,2,6]`。

思路

1. 先找出最大的索引 `k` 满足 `nums[k] < nums[k+1]`，如果不存在，就翻转整个数组；
2. 再找出另一个最大索引 `l` 满足 `nums[l] > nums[k]`；
3. 交换 `nums[l]` 和 `nums[k]`；
4. 最后翻转 `nums[k+1:]`。

## 提交速度

- 执行用时：`64 ms`, 在所有 JavaScript 提交中击败了`98.18%`的用户
- 内存消耗：`41.5 MB`, 在所有 JavaScript 提交中击败了`11.65%`的用户
