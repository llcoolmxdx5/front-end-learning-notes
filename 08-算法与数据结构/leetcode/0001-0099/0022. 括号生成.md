# [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

## 题目

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且**有效的**括号组合。

有效括号组合需满足：左括号必须以正确的顺序闭合。

示例 1：

```txt
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

示例 2：

```txt
输入：n = 1
输出：["()"]
```

提示：

- `1 <= n <= 8`

## 难度

中等

## 标签

字符串 动态规划 回溯

## 解题思路

我们可以只在序列仍然保持有效时才添加 '(' or ')'。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，

如果左括号数量不大于 `n`，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。

复杂度分析

我们的复杂度分析依赖于理解 `generateParenthesis(n)` 中有多少个元素。这个分析超出了本文的范畴，但事实证明这是第 `n` 个卡特兰数 这是由 `4^n / n^1/2` 渐近界定的。

- 时间复杂度：`O(4^n / n^1/2)`，在回溯过程中，每个答案需要 `O(n)` 的时间复制到答案数组中。
- 空间复杂度：`O(n)`，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 `O(1)` 的空间，最多递归 `2n` 层，因此空间复杂度为 `O(n)`。

## 提交速度

- 执行用时：`68 ms`, 在所有 JavaScript 提交中击败了`82.41%`的用户
- 内存消耗：`39.4 MB`, 在所有 JavaScript 提交中击败了`28.51%`的用户
