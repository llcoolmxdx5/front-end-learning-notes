# [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

## 题目

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

示例 1：

```txt
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

示例 2：

```txt
输入：nums = [1]
输出：1
```

示例 3：

```txt
输入：nums = [5,4,-1,7,8]
输出：23
```

提示：

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

进阶：如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的**分治法**求解。

## 难度

简单

## 标签

数组 分治 动态规划

## 解题思路

### 方法一：动态规划

我们用 `dp[i]` 代表以第 `i` 个数结尾的「连续子数组的最大和」

假设数组 `nums` 的值全都严格大于 0，那么一定有 dp[i] = `dp[i - 1] + nums[i]`。

可是 `dp[i - 1]` 有可能是负数，于是分类讨论：

- 如果 `dp[i - 1] > 0`，那么可以把 `nums[i]` 直接接在 `dp[i - 1]` 表示的那个数组的后面，得到和更大的连续子数组；
- 如果 `dp[i - 1] <= 0`，那么 `nums[i]` 加上前面的数 `dp[i - 1]` 以后值不会变大。于是 `dp[i]` 「另起炉灶」，此时单独的一个 `nums[i]` 的值，就是 `dp[i]`

### 方法二：分治法

分治法的思路是这样的，其实也是分类讨论。

连续子序列的最大和主要由这三部分子区间里元素的最大和得到：

1. 第 1 部分：左子区间 `[left, mid]`；
2. 第 2 部分：右子区间 `[mid + 1, right]`；
3. 第 3 部分：包含子区间 `[mid , mid + 1]` 的子区间，即 `nums[mid]` 与 `nums[mid + 1]` 一定会被选取。

对这三个部分求最大值即可。

说明：考虑第 3 部分跨越两个区间的连续子数组的时候，由于 `nums[mid]` 与 `nums[mid + 1]` 一定会被选取，可以从中间向两边扩散，扩散到底 选出最大值

## 提交速度

- 执行用时：`92 ms`, 在所有 JavaScript 提交中击败了`62.71%`的用户
- 内存消耗：`51.2 MB`, 在所有 JavaScript 提交中击败了`12.81%`的用户
