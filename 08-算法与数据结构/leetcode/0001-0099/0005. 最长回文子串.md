# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

## 题目

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

示例 1：

```txt
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

示例 2：

```txt
输入：s = "cbbd"
输出："bb"
```

示例 3：

```txt
输入：s = "a"
输出："a"
```

示例 4：

```txt
输入：s = "ac"
输出："a"
```

提示：

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

## 难度

中等

## 标签

字符串 动态规划

## 解题思路

对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 `“ababa”`，如果我们已经知道 `“bab”` 是回文串，那么 `“ababa”` 一定是回文串，这是因为它的首尾两个字母都是 `“a”`

按照此方式去掉首尾字符串得到最小子串, 子串的长度为 1 或 2。对于长度为 1 的子串，它显然是个回文串；对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。

## 动态规划

定义 `dp[i][j]` 表示字符串 `s` 的第 `i` 到 `j` 个字母组成的串（下文表示成 `s[i, j]`）是否为回文串

子串是回文串 `true, i > j` 不合法 `false`, 子串不是回文串 `false`

当 `s[i] === s[j]` 时, 状态转移方程 `dp[i][j] === dp[i+1][j-1]` 成立

考虑边界情况, 即子串长度为 1 或 2 时, `dp[i][i]` 为 `true`, 当 `s[i] === s[i+1]` 时 `dp[i][i+1]`

### 中心扩展算法

得到的最小子串可以作为回文串中心, 我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案

复杂度分析

- 时间复杂度：`O(n^2)`，其中 `n` 是字符串的长度。长度为 1 和 2 的回文中心分别有 `n` 和 `n-1` 个，每个回文中心最多会向外扩展 `O(n)` 次。
- 空间复杂度：`O(1)`。

## 提交速度

执行用时：`84 ms`, 在所有 JavaScript 提交中击败了 `99.52%` 的用户
内存消耗：`40.5 MB`, 在所有 JavaScript 提交中击败了 `69.40%` 的用户
