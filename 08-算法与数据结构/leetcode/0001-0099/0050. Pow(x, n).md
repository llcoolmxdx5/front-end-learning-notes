# [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

## 题目

实现 `pow(x, n)`，即计算 `x` 的 `n` 次幂函数（即，`x^n`）。

示例 1：

```txt
输入：x = 2.00000, n = 10
输出：1024.00000
```

示例 2：

```txt
输入：x = 2.10000, n = 3
输出：9.26100
```

示例 3：

```txt
输入：x = 2.00000, n = -2
输出：0.25000
解释：2^-2 = 1/22 = 1/4 = 0.25
```

提示：

- `-100.0 < x < 100.0`
- `-2^31 <= n <= 2^31-1`
- `-10^4 <= x^n <= 10^4`

## 难度

中等

## 标签

数学 递归

## 解题思路

### 方法一：快速幂 + 递归

「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 `x^64`，我们可以按照：`x -> x^2 -> x^4 -> x^8 -> x^16 -> x^32 -> x^64` 的顺序，从 `x` 开始，每次直接把上一次的结果进行平方，计算 6 次就可以得到 `x^64` 的值，而不需要对 `x` 乘 63 次 `x`。

再举一个例子，如果我们要计算 `x^77`，我们可以按照：`x -> x^2 ->x^4 -> x^9 -> x^19 -> x^38 -> x^77` 的顺序，在 `x -> x^2 ->x^4 x^19 -> x^38` 这些步骤中，我们直接把上一次的结果进行平方，而在 `x^4 -> x^9 -> x^19 x^38 -> x^77` 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 `x`。

直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 `x`。但如果我们从右往左看，分治的思想就十分明显了

- 当我们要计算 `x^n` 时，我们可以先递归地计算出 `y = x^Math.floor(x / 2)`；
- 根据递归计算的结果，如果 `n` 为偶数，那么 `x^n = y^2`；如果 `n` 为奇数，那么 `x^n = y^2 * x`
- 递归的边界为 `n = 0`，任意数的 0 次方均为 1。

由于每次递归都会使得指数减少一半，因此递归的层数为 `O(logn)`，算法可以在很快的时间内得到结果。

复杂度分析

- 时间复杂度：`O(logn)`，即为递归的层数。
- 空间复杂度：`O(logn)`，即为递归的层数。这是由于递归的函数调用会使用栈空间。

### 方法二：快速幂 + 迭代

由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。

每个二进制数位都有一个权值，权值如下图所示，最终结果就等于所有二进制位为 1 的权值之积，, 例如上述 `x^77` 次方对应的二进制 (`1001101`) 和每个二进制位的权值如下

```txt
1    0    0    1   1   0   1
x^64 x^32 x^16 x^8 x^4 x^2 x^1

最终结果就是所有二进制位为1的权值之积：x^1 * x^4 * x^8 * x^64 = x^77
```

而且我们不必预先把每一个二进制位的权值计算出来，我们可以一边计算结果，一边计算权值

复杂度分析

- 时间复杂度：`O(logn)`，即为对 `n` 进行二进制拆分的时间复杂度。
- 空间复杂度：`O(1)`。

## 提交速度

- 执行用时：`68 ms`, 在所有 JavaScript 提交中击败了 `87.61%` 的用户
- 内存消耗：`38.7 MB`, 在所有 JavaScript 提交中击败了 `92.58%` 的用户
