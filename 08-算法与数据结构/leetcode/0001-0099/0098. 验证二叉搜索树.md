# [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

## 题目

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效**二叉搜索树定义如下：

- 节点的左子树只包含**小于**当前节点的数。
- 节点的右子树只包含**大于**当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

示例 1：

```txt
输入：root = [2,1,3]
输出：true
```

示例 2：

```txt
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

提示：

- 树中节点数目范围在 `[1, 10^4]` 内
- `-2^31 <= Node.val <= 2^31 - 1`

## 难度

中等

## 标签

树 深度优先搜索 二叉搜索树 二叉树

## 解题思路

### 方法一: 递归

二叉搜索树最重要的就是对节点值的限制，我们如果能正确卡住每个节点的值，就可以判断了。

如何判断节点值是否正确呢？我们可以用递归的方式倒推，即从根节点开始，假设根节点值为 `x`，那么左树节点的值就必须小于 `x`，再往左，那么值就要小于（假设第一个左节点值为 `x1`） `x1`，右树也是一样判断

### 方法二：中序遍历

二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是。

## 提交速度

- 执行用时：`48 ms`, 在所有 JavaScript 提交中击败了`99%`的用户
- 内存消耗：`45.1 MB`, 在所有 JavaScript 提交中击败了`35%`的用户
