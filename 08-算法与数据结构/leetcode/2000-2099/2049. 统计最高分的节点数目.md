# [2049. 统计最高分的节点数目](https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/)

## 题目

给你一棵根节点为 0 的**二叉树**，它总共有 `n` 个节点，节点编号为 0 到 `n - 1` 。同时给你一个下标从 0 开始的整数数组 `parents` 表示这棵树，其中 `parents[i]` 是节点 `i` 的父节点。由于节点 0 是根，所以 `parents[0] == -1` 。

一个子树的**大小**为这个子树内节点的数目。每个节点都有一个与之关联的**分数**。求出某个节点分数的方法是，将这个节点和与它相连的边全部**删除**，剩余部分是若干个**非空**子树，这个节点的**分数**为所有这些子树**大小的乘积**。

请你返回有**最高得分**节点的**数目**。

示例 1:

```txt
输入：parents = [-1,2,0,2,0]
输出：3
解释：
- 节点 0 的分数为：3 * 1 = 3
- 节点 1 的分数为：4 = 4
- 节点 2 的分数为：1 * 1 * 2 = 2
- 节点 3 的分数为：4 = 4
- 节点 4 的分数为：4 = 4
最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。
```

示例 2：

```txt
输入：parents = [-1,2,0]
输出：2
解释：
- 节点 0 的分数为：2 = 2
- 节点 1 的分数为：2 = 2
- 节点 2 的分数为：1 * 1 = 1
最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。
```

提示：

- `n == parents.length`
- `2 <= n <= 105`
- `parents[0] == -1`
- 对于 `i != 0` ，有 `0 <= parents[i] <= n - 1`
- `parents` 表示一棵二叉树。

## 难度

中等

## 标签

树 深度优先搜索 数组 二叉树

## 解题思路

删除某个节点之后，最多会把二叉树分割成 三个部分 ：左子树、右子树、父节点及父节点的另一半子树（下面简称：父子树）。

而我们知道，通过深度优先搜索我们是可以求出左右子树的节点数量的，这样的话，父子树的数量也就很容易求得了，为 总节点数 减去 左右子树的数量 再减 一。

那么，上面三个数量都有了之后，相乘就是删除这个节点之后的分数，当然，这里有可能三个部分中缺失一部分或者两部分，缺失的部分我们用 1 来代替去相乘即可。

然而，题目给定的是一个表示父节点的数组，所以，我们第一步是要先构造出来这颗二叉树

## 提交速度

执行用时：
288 ms
, 在所有 JavaScript 提交中击败了
100.00%
的用户
内存消耗：
82 MB
, 在所有 JavaScript 提交中击败了
70.00%
的用户
