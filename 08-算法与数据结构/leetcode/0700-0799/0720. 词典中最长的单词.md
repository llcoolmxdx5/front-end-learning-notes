# [720. 词典中最长的单词](https://leetcode-cn.com/problems/longest-word-in-dictionary/)

## 题目

给出一个字符串数组 `words` 组成的一本英语词典。返回 `words` 中最长的一个单词，该单词是由 `words` 词典中其他单词逐步添加一个字母组成。

若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。

示例 1：

```txt
输入：words = ["w","wo","wor","worl", "world"]
输出："world"
解释： 单词"world"可由"w", "wo", "wor", 和 "worl"逐步添加一个字母组成。
```

示例 2：

```txt
输入：words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
输出："apple"
解释："apply" 和 "apple" 都能由词典中的单词组成。但是 "apple" 的字典序小于 "apply"
```

提示：

- `1 <= words.length <= 1000`
- `1 <= words[i].length <= 30`
- 所有输入的字符串 `words[i]` 都只包含小写字母。

## 难度

简单

## 标签

字典树 数组 哈希表 字符串 排序

## 解题思路

### 方法一 哈希表

使用哈希表的时候我们需要先对给定数组按长度从小到大排个序，然后依次遍历，遍历到某个字符串就看它减去一个长度的字符串在哈希表中是否存在，如果存在，说明这个字符串可能是候选的结果，如果不存在，说明这个字符串肯定不是候选的结果，因为题目要求了必须是逐步增长的。

为了方便处理呢，可以在排序的时候做个小手脚，当长度相等时，把字典序更大的排在前面，这样，遍历到后面的就是字典序较小的，如果前面已经有相同长度的，直接返回后面的就是符合题目要求的，否则，你还得判断一下，当前遍历到的字符串是否比候选结果中的字典序更小。

## 提交速度

- 执行用时：`136 ms`, 在所有 JavaScript 提交中击败了`16.59%`的用户
- 内存消耗：`47.6 MB`, 在所有 JavaScript 提交中击败了`15.12%`的用户
