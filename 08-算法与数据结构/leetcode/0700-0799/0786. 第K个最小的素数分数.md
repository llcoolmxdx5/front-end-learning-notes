# [786. 第K个最小的素数分数](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)

## 题目

给你一个按递增顺序排序的数组 `arr` 和一个整数 `k` 。数组 `arr` 由 1 和若干**素数**组成，且其中所有整数互不相同。

对于每对满足 `0 < i < j < arr.length` 的 `i` 和 `j` ，可以得到分数 `arr[i] / arr[j]` 。

那么第 `k` 个最小的分数是多少呢? 以长度为 2 的整数数组返回你的答案, 这里 `answer[0] == arr[i]` 且 `answer[1] == arr[j]` 。

示例 1：

```txt
输入：arr = [1,2,3,5], k = 3
输出：[2,5]
解释：已构造好的分数,排序后如下所示:
1/5, 1/3, 2/5, 1/2, 3/5, 2/3
很明显第三个最小的分数是 2/5
```

示例 2：

```txt
输入：arr = [1,7], k = 1
输出：[1,7]
```

提示：

- `2 <= arr.length <= 1000`
- `1 <= arr[i] <= 3 * 10^4`
- `arr[0] == 1`
- `arr[i]` 是一个**素数**，`i > 0`
- `arr` 中的所有数字**互不相同**，且按**严格递增**排序
- `1 <= k <= arr.length * (arr.length - 1) / 2`

## 难度

困难

## 标签

数组 二分查找 堆(优先队列)

## 解题思路

当我们比较两个分数 `a/b` 和 `c/d` 时，我们可以直接对它们的值进行比较，但这会产生浮点数的计算，降低程序的效率，并且可能会引入浮点数误差。一种可行的替代方法是用：`a×d<b×c` 来替代 `a/b < c/d` 的判断，二者是等价的。

### 方法一：优先队列

求最小 TopK，用小顶堆（即优先队列），第 K 个出堆的元素就是最小 TopK。

两种思路的时间复杂度：

1. 构造完整堆 `O(N^2)` + 出堆 `O(K)` = `O(N^2 + K)`
2. 一边入堆，一边出堆: `O(N)`

NOTICE

一边入堆，一边出堆，为什么能保证出堆的分数是升序？

- 首批入堆元素，包含第 1 小的分数，即 `arr[0] / arr[N-1]`
- 第 1 次出堆的是第 1 小的分数，而第 2 小的分数，要么是即将入堆的 `arr[1] / arr[N-1]`，要么是已经在堆中的 `arr[0] / arr[N-2]`
- 那么第 2 次出堆的就肯定是第 2 小的分数
- 以此类推，每当第 `m` 次的出堆后，第 `m+1` 次出堆前，会确保第 `m+1` 小的分数在堆中，所以第 `m+1` 次出堆得到第 `m+1` 小的分数
- 所以出堆的顺序就总是升序的，即使堆中并不同时包含可构造的所有分数

复杂度分析

- 时间复杂度：`O(k logn)`，其中 nn 是数组 `arr` 的长度。优先队列的单次操作时间复杂度为 `O(logn)`，一共需要进行 `O(k)` 次操作。
- 空间复杂度：`O(n)`，即为优先队列需要使用的空间。

## 提交速度

- 执行用时：`576 ms`, 在所有 JavaScript 提交中击败了 `92.31%` 的用户
- 内存消耗：`45.5 MB`, 在所有 JavaScript 提交中击败了 `100.00%` 的用户
