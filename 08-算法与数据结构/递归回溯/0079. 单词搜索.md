# [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

## 题目

给定一个 `m x n` 二维字符网格  `board` 和一个字符串单词  `word` 。如果  `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

```txt
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

示例 2：

```txt
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

示例 3：

```txt
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

提示：

- `m == board.length`
- `n = board[i].length`
- `1 <= m`, `n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

## 难度

中等

## 标签

数组 回溯 矩阵

## 解题思路

使用深度优先搜索（DFS）和回溯的思想实现。关于判断元素是否使用过，用了一个二维数组 `used` 对使用过的元素做标记。

1. 首先遍历 board 的所有元素，先找到和 `word` 第一个字母相同的元素，然后进入递归流程。假设这个元素的坐标为 `(i, j)`，进入递归流程前，先记得把该元素打上使用过的标记：`used[row][col] = true;`
2. 好了，打完标记了，现在我们进入了递归流程。递归流程主要做了这么几件事：

   - 从 `(i, j)` 出发，朝它的上下左右试探，看看它周边的这四个元素是否能匹配 `word` 的下一个字母
   - 如果匹配到了：带着该元素继续进入下一个递归
   - 如果都匹配不到：返回 `false`
   - 当 `word` 的所有字母都完成匹配后，整个流程返回 True

注意点

- 递归时元素的坐标是否超过边界
- 回溯标记 `used[row][col] = false;` 以及 `return` 的时机

用 `Set` 去重极慢

## 提交速度

- 执行用时：`348 ms`, 在所有 JavaScript 提交中击败了 `52.41%` 的用户
- 内存消耗：`38.2 MB`, 在所有 JavaScript 提交中击败了 `78.29%` 的用户
