# [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

## 题目

给定一个数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用一次。

注意：解集不能包含重复的组合。

示例 1:

```txt
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

示例 2:

```txt
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```

提示:

- `1 <= candidates.length <= 100`
- `1 <= candidates[i] <= 50`
- `1 <= target <= 30`

## 难度

中等

## 标签

数组 回溯

## 解题思路

把所有组合求出来，再用 `set` 或者 `map` 去重，这么做很容易超时！所以要在搜索的过程中就去掉重复组合。

组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。与 39.组合总和套路相同，此题还需要加一个 `bool` 型数组 `used` ，用来记录同一树枝上的元素是否使用过。**树层去重的话，需要对数组排序！**

这个集合去重的重任就是 `used` 来完成的。

如果 `candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了 `candidates[i - 1]`，也就是说同一树层使用过 `candidates[i - 1]`。此时 `for` 循环里就应该做 `continue` 的操作。

在 `candidates[i] == candidates[i - 1]` 相同的情况下：

- `used[i - 1] == true`，说明同一树支 `candidates[i - 1]` 使用过
- `used[i - 1] == false`，说明同一树层 `candidates[i - 1]` 使用过

![alt](./imgs/40-去重.png)

## 提交速度

- 执行用时：`72 ms`, 在所有 JavaScript 提交中击败了 `91.09%` 的用户
- 内存消耗：`39.6 MB`, 在所有 JavaScript 提交中击败了 `56.06%` 的用户
