# [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

## 题目

给定一个数组，将数组中的元素向右移动  `k`  个位置，其中  `k`  是非负数。

进阶：

- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 你可以使用空间复杂度为  `O(1)` 的   原地   算法解决这个问题吗？

示例 1:

```txt
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

示例  2:

```txt
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释:
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```

提示：

- `1 <= nums.length <= 2 * 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `0 <= k <= 10^5`

## 难度

中等

## 标签

数组 数学 双指针

## 解题思路

### 使用额外的数组

切片 length-k,length-1 + 0, length-k

- 时间复杂度：`O(n)`，其中 `n` 为数组的长度。
- 空间复杂度：`O(n)`

### 数组翻转

该方法基于如下的事实：当我们将数组的元素向右移动 `k` 次后，尾部 `k mod n` 个元素会移动至数组头部，其余元素向后移动 `k mod n` 个位置。

该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的 `k mod n` 个元素就被移至数组头部，然后我们再翻转 `[0, k mod n - 1]` 区间的元素和 `[k mod n,n−1]` 区间的元素即能得到最后的答案。

- 时间复杂度：`O(n)`，其中 `n` 为数组的长度。
- 空间复杂度：`O(1)`

## 提交速度

- 执行用时：`92 ms`, 在所有 JavaScript 提交中击败了 `98.88%` 的用户
- 内存消耗：`48.8 MB`, 在所有 JavaScript 提交中击败了 `21.68%` 的用户
