# [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

## 题目

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums`，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、1 和 2 分别表示红色、白色和蓝色。

必须在不使用库的 `sort函数` 的情况下解决这个问题。

示例 1：

```txt
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

示例 2：

```txt
输入：nums = [2,0,1]
输出：[0,1,2]
```

提示：

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 0、1 或 2

进阶：

- 你可以不使用代码库中的排序函数来解决这道题吗？
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

## 难度

中等

## 标签

数组 双指针 排序

## 解题思路

### 方法一：单指针

我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 0 交换到数组的头部。在第二次遍历中，我们将数组中所有的 1 交换到头部的 0 之后。此时，所有的 2 都出现在数组的尾部，这样我们就完成了排序。

### 方法二：双指针

方法一需要进行两次遍历，那么我们是否可以仅使用一次遍历呢？我们可以额外使用一个指针，即使用两个指针分别用来交换 00 和 11

具体地，我们用指针 `p0` 来交换 0，`p1` 来交换 1，初始值都为 0。当我们从左向右遍历整个数组时：

- 如果找到了 1，那么将其与 `nums[p1]` 进行交换，并将 `p1` 向后移动一个位置，这与方法一是相同的
- 如果找到了 0，那么将其与 `nums[p0]` 进行交换，并将 `p0` 向后移动一个位置。这样做是正确的吗？我们可以注意到，因为连续的 0 之后是连续的 1，因此如果我们将 0 与 `nums[p0]` 进行交换，那么我们可能会把一个 1 交换出去。当 `p0 <p1` 时，我们已经将一些 1 连续地放在头部，此时一定会把一个 1 交换出去，导致答案错误。因此，如果 `p0 <p1` ，那么我们需要再将 `nums[i]` 与 `nums[p1]` 进行交换，其中 `i` 是当前遍历到的位置，在进行了第一次交换后，`nums[i]` 的值为 1，我们需要将这个 1 放到「头部」的末端。在最后，无论是否有 `p0 < p1` ，我们需要将 `p0` 和 `p1` 均向后移动一个位置，而不是仅将 `p0` 向后移动一个位置。

### 方法三：双指针

0 挪到最前面，2 挪到最后面就完事儿了
注意 2 挪完如果换出来的不是 1，那么指针要回退，因为 0 和 2 都是需要再次移动的

## 提交速度

- 执行用时：`64 ms`, 在所有 JavaScript 提交中击败了`79.79%`的用户
- 内存消耗：`41.8 MB`, 在所有 JavaScript 提交中击败了`5.02%`的用户
