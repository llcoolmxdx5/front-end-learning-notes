# [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

## 题目

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

示例 1：

```txt
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

示例 2：

```txt
输入：nums = [0,1,0,3,2,3]
输出：4
```

示例 3：

```txt
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

提示：

- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

进阶：

- 你可以设计时间复杂度为 `O(n^2)` 的解决方案吗？
- 你能将算法的时间复杂度降低到  `O(n log(n))` 吗?

## 难度

中等

## 标签

数组 二分查找 动态规划

## 解题思路

### 方法一：动态规划

按照套路，`dp(i)` 就表示以第 `i` 个字符串结尾的最长上升子序列长度，那么重点是，`dp(i)` 怎么通过之前的推导出来呢？

由于是不连续的，因此不能只看 `dp(i-1)` 了，因为 `nums[i]` 项与 `dp(j)`（其中 `0 <= j < i`）组合后都可能达到最大长度，因此需要遍历所有 `j`，尝试其中最大长度的组合。

所以状态转移方程为：`dp[i] = max(dp[j]) + 1`，其中 `0<=j<i` 且 `nums[j]<nums[i]`。

复杂度分析

- 时间复杂度：`O(n^2)`，其中 `n` 是数组 `nums` 的长度。
- 空间复杂度：`O(n)`。需要额外使用长度为 `n` 的 `dp` 数组。

### 方法二：贪心 + 二分查找

降低复杂度切入点： 解法一中，遍历计算 `dp` 列表需 `O(N)`，计算每个 `dp[k]` 需 `O(N)`。

1. 动态规划中，通过线性遍历来计算 `dp` 的复杂度无法降低；
2. 每轮计算中，需要通过线性遍历 `[0,k)` 区间元素来得到 `dp[k]` 。我们考虑：是否可以通过重新设计状态定义，使整个 `dp` 为一个排序列表；这样在计算每个 `dp[k]` 时，就可以通过二分法遍历 `[0,k)` 区间元素，将此部分复杂度由 `O(n)` 降至 `O(logn)`。

我们考虑维护一个列表 `tails`，其中每个元素 `tails[k]` 的值代表 长度为 `k+1` 的子序列尾部元素的值。如 `[1,4,6]` 序列，长度为 1,2,3 的子序列尾部元素值分别为 `tails = [1,4,6]`。

设常量数字 `N`，和随机数字 `x`，我们可以容易推出：当 `N` 越小时，`N<x` 的几率越大。例如： `N=0` 肯定比 `N=1000` 更可能满足 `N<x`。在遍历计算每个 `tails[k]`，不断更新长度为 `[1,k]` 的子序列尾部元素值，始终保持每个尾部元素值最小 （例如 `[1,5,3]`， 遍历到元素 5 时，长度为 2 的子序列尾部元素值为 5；当遍历到元素 3 时，尾部元素值应更新至 3，因为 3 遇到比它大的数字的几率更大）。

`tails` 列表一定是严格递增的： 即当尽可能使每个子序列尾部元素值最小的前提下，子序列越长，其序列尾部元素值一定更大。既然严格递增，每轮计算 `tails[k]` 时就可以使用二分法查找需要更新的尾部元素值的对应索引 `i`。

复杂度分析：

- 时间复杂度 `O(nlogn)` ： 遍历 `nums` 列表需 `O(n)`，在每个 `nums[i]` 二分法需 `O(logn)`。
- 空间复杂度 `O(n)` ： `tails` 列表占用线性大小额外空间。

## 提交速度

- 执行用时：`72 ms`, 在所有 `JavaScript` 提交中击败了 `96.39%` 的用户
- 内存消耗：`39.3 MB`, 在所有 `JavaScript` 提交中击败了 `79.11%` 的用户
