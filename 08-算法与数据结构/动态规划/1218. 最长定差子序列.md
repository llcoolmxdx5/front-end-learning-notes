# [1218. 最长定差子序列](https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/)

## 题目

给你一个整数数组 `arr` 和一个整数 `difference`，请你找出并返回 `arr` 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 `difference` 。

子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。

示例 1：

```txt
输入：arr = [1,2,3,4], difference = 1
输出：4
解释：最长的等差子序列是 [1,2,3,4]。
```

示例  2：

```txt
输入：arr = [1,3,5,7], difference = 1
输出：1
解释：最长的等差子序列是任意单个元素。
```

示例 3：

```txt
输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2
输出：4
解释：最长的等差子序列是 [7,5,3,1]。
```

提示：

- `1 <= arr.length <= 10^5`
- `-10^4 <= arr[i], difference <= 10^4`

## 难度

中等

## 标签

数组 哈希表 动态规划

## 解题思路

### 动态规划

按照套路，`dp(i)` 就表示以第 `i` 个字符串结尾的最长上升子序列长度，那么重点是，`dp(i)` 怎么通过之前的推导出来呢？

由于是不连续的，因此不能只看 `dp(i-1)` 了，因为 `arr[i]` 项与 `dp(j)`（其中 `0 <= j < i`）组合后都可能达到最大长度，因此需要遍历所有 `j`，尝试其中最大长度的组合。

所以状态转移方程为：`dp[i] = max(dp[j]) + 1`，其中 `0<=j<i` 且 `arr[i] = arr[j] + d`。

由于我们总是在左侧找一个最近的等于 `arr[i]−d` 元素并取其对应 `dp` 值，因此我们直接用 `dp[v]` 表示以 `v` 为结尾的最长的等差子序列的长度，这样 `dp[v−d]` 就是我们要找的左侧元素对应的最长的等差子序列的长度，因此转移方程可以改为 `dp[v]=dp[v−d]+1`

最后答案为 `max{dp}`。

复杂度分析

- 时间复杂度：`O(n)`，其中 `n` 是数组 `arr` 的长度。
- 空间复杂度：`O(n)`。哈希表需要 `O(n)` 的空间。

## 提交速度

- 执行用时：`116 ms`, 在所有 `JavaScript` 提交中击败了 `62.50%` 的用户
- 内存消耗：`47.8 MB`, 在所有 `JavaScript` 提交中击败了 `87.50%` 的用户
